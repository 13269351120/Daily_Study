# Learn MarkDown  
***
今天是第一次使用MarkDown记录每日的所学所闻,很开心能使用大牛们为了方便我们生活创造的工具!能够站在巨人的肩膀上,我们很幸运!感恩大牛~
***

***
# 图形着色器——理论与实践 读书笔记
***
## 第一章 固定功能管线
***
### 传统的视见方案:
```
引子: 一种最为简单的OpenGL考察方式 是将其 视为 两个连接操作:顶点处理操作 和 像素处理操作
```
<div align=center>
<img width="300" height="320" src="https://github.com/13269351120/Daily_Study/raw/master/2018.11.17/OpenGL%20Vertex%20processing.png"/ alt = "OpenGL Vertex Processing">
</div>


__顶点操作分成若干个阶段__:
*	1.定义了模型空间 , 组成场景的基本几何体: 
输入 :  顶点定义集 glVertex * glNormal* glTexCoord* 函数所调用的内容 以及 分组
输出 :  模型坐标的顶点集
简介 :  这个步骤 在自身的模型空间内建模 , 坐标空间可为任意形式 , 进而方便地定义 顶点 以及模型关系 ,这个步骤 就相当于 输入一堆点 , 开始的时候这堆点 还没有 联系在一起 , 经过这个步骤 , 就会把这些点 该连的联系在一起 , 该分开的 分开

* 2.定义了世界空间 ,将所有的独立模型置于 该空间中内进行变换 :
	输入 :  模型转换 如缩放 旋转 以及平移 glRotatef() glTranlatef() glScalef()
	输出 :  调整后的顶点和法线数据的集合 
	简介 : 第一个步骤 将 顶点有序的连接形成了 模型 , 第二个步骤就是在世界空间中 去操作这些模型 , 这个阶段不会影响 颜色 材质 纹理坐标 以及分组 , 但会改变 顶点 法线 以及光照产生影响 , 因为通常情况下 , 光源 定义在世界空间内 .
	
* 3.定义了眼睛(相机)空间 :
	输入 : 视见环境定义 , 通常会使用GLU函数 gluLookAT()
	输出 : 包含原始信息的,经过调整后的几何体 
	简介 : 这个步骤 和 最后渲染出来的图像 联系十分紧密 , 针对后序处理的全部深度信息均来自该眼睛空间的z坐标值 并且 定义了模型视见矩阵, 眼睛的位置一旦发生改变 , 顶点的位置 , 法线值 光源位置 都需要重新进行计算 
* 4.定义了视口转换
	输入 : 第三个步骤的 信息 
	输出 : 整型像素x,y坐标的顶点集合并包含分组信息 法线 深度值 纹理坐标 以及颜色等信息
	简介 : 此步骤可以分为两个主要操作 , 第一个 还是在3D空间下进行 第二个在2D空间中
	首先 根据透视定义 在 裁剪空间边界上对几何体实施裁剪操作 ,因为裁剪操作 会造成顶点像素的添加 或 删除 , 需要对新的图元 或对原有图元 进行适当的调整 , 新增顶点像素 应包含 新的颜色值 或 纹理坐标 , 对应插值计算类似于渲染过程中的插值计算 
	其次 , 3D裁剪空间 转换至 特定视口的2D整型,同时 z坐标转换为深度值并用于渲染
***
__总结__:
以上描述了4个顶点操作,从模型空间到世界空间再到相机空间最后到屏幕空间(中间可能严格分 还有裁剪空间等 , 但是都是细节 未来再具体涉及深入) , 每一次空间上的转换都很有逻辑 , 很容易理解 . 下图是通过传入 三角形的三个顶点 来生成 屏幕上的三角形的流程图 .
<div align=center><img width="350" height="300" src="https://github.com/13269351120/Daily_Study/raw/master/2018.11.17/Graphics%20Pipeline.png"/></div>

主要可以分为 模型转换(M) 视见转换(V) 投影转换(P) , 很复杂 , OpenGL采用了 更为统一的转换版本 , 将模型转换和视见转换整合成一个.
模型在一次次转换的时候,为了记录下转换的信息 , 需要维护一个转换栈,每一次操作都记录下来(glPushMatrix() ) , 如果要恢复就(glPopMatrix() )就可以了 , 从侧面也反映出栈是一种 重要的数据结构 ,维护信息时大有用途!

